<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Gelora - Ground First Discovery</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <style>
        body { 
            margin: 0; 
            font-family: Arial; 
            overflow: hidden; 
            background: #0a0a0a;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
        }
        
        .start-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 40px;
            border-radius: 30px;
            text-align: center;
            font-size: 16px;
            font-weight: 300;
            max-width: 80%;
            backdrop-filter: blur(10px);
            z-index: 10000;
        }
        
        .ground-instructions {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.4);
            color: rgba(255,255,255,0.8);
            padding: 8px 16px;
            border-radius: 15px;
            text-align: center;
            font-size: 10px;
            backdrop-filter: blur(3px);
            font-weight: 300;
            display: none;
        }
        
        .awareness-counter {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(0,0,0,0.3);
            color: rgba(255,255,255,0.7);
            padding: 5px 8px;
            border-radius: 8px;
            font-weight: 300;
            font-size: 9px;
            backdrop-filter: blur(2px);
        }
        
        /* Smaller glowing dots positioned at bottom for upward dragging */
        .glowing-dot {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            pointer-events: all;
            cursor: grab;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px currentColor;
            border: 2px solid currentColor;
            opacity: 0;
            display: none;
        }
        
        .glowing-dot:active {
            cursor: grabbing;
            transform: scale(1.3);
        }
        
        .dot-green {
            background: radial-gradient(circle, rgba(0,255,127,0.7) 0%, rgba(0,255,127,0.3) 70%, transparent 100%);
            color: rgba(0,255,127,1);
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            animation: pulseGreen 1.5s ease-in-out infinite;
        }
        
        .dot-pink {
            background: radial-gradient(circle, rgba(255,20,147,0.7) 0%, rgba(255,20,147,0.3) 70%, transparent 100%);
            color: rgba(255,20,147,1);
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            animation: pulsePink 1.5s ease-in-out infinite;
        }
        
        .dot-white {
            background: radial-gradient(circle, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0.3) 70%, transparent 100%);
            color: rgba(255,255,255,1);
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            animation: pulseWhite 1.5s ease-in-out infinite;
        }
        
        .dot-blue {
            background: radial-gradient(circle, rgba(173,216,230,0.7) 0%, rgba(173,216,230,0.3) 70%, transparent 100%);
            color: rgba(173,216,230,1);
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            animation: pulseBlue 1.5s ease-in-out infinite;
        }
        
        @keyframes pulseGreen {
            0%, 100% { box-shadow: 0 0 20px rgba(0,255,127,0.8); }
            50% { box-shadow: 0 0 30px rgba(0,255,127,1), 0 0 40px rgba(0,255,127,0.6); }
        }
        
        @keyframes pulsePink {
            0%, 100% { box-shadow: 0 0 20px rgba(255,20,147,0.8); }
            50% { box-shadow: 0 0 30px rgba(255,20,147,1), 0 0 40px rgba(255,20,147,0.6); }
        }
        
        @keyframes pulseWhite {
            0%, 100% { box-shadow: 0 0 20px rgba(255,255,255,0.8); }
            50% { box-shadow: 0 0 30px rgba(255,255,255,1), 0 0 40px rgba(255,255,255,0.6); }
        }
        
        @keyframes pulseBlue {
            0%, 100% { box-shadow: 0 0 20px rgba(173,216,230,0.8); }
            50% { box-shadow: 0 0 30px rgba(173,216,230,1), 0 0 40px rgba(173,216,230,0.6); }
        }
        
        /* Center target area for upward dragging */
        .center-target {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 2px dashed rgba(255,255,255,0.4);
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        }
        
        .ground-complete {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.4);
            color: rgba(255,255,255,0.8);
            padding: 12px 20px;
            border-radius: 15px;
            font-size: 10px;
            display: none;
            text-align: center;
            backdrop-filter: blur(3px);
            font-weight: 300;
        }
    </style>
</head>
<body>
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false">
        <!-- Container for ground-aware memories -->
        <a-entity id="ground-container"></a-entity>
        
        <a-entity camera look-controls="enabled: true; pointerLockEnabled: false" wasd-controls="enabled: false"></a-entity>
    </a-scene>

    <div class="overlay">
        <div class="start-instructions" id="startInstructions">
            Point your camera toward the ground first<br>
            <small style="margin-top: 10px; display: block; opacity: 0.8;">Then the experience will begin...</small>
        </div>
        
        <div class="ground-instructions" id="instructions">
            Drag green dot to center target
        </div>
        
        <div class="awareness-counter" id="progress">
            <span id="count">0</span>/4
        </div>
        
        <!-- SEQUENTIAL DOTS - All hidden initially -->
        <div class="glowing-dot dot-green" id="dotGreen"></div>
        <div class="glowing-dot dot-pink" id="dotPink"></div>
        <div class="glowing-dot dot-white" id="dotWhite"></div>
        <div class="glowing-dot dot-blue" id="dotBlue"></div>
        
        <!-- Drag trail line -->
        <div class="drag-line" id="dragLine"></div>
        
        <!-- Center target -->
        <div class="center-target" id="centerTarget"></div>
        
        <div class="ground-complete" id="groundComplete">
            Ground awareness complete<br>
            <small>Walk around fallen memories</small>
        </div>
    </div>

    <script>
        // Ground awareness configuration - surrounding audience formation
        const groundMemories = [
            {
                id: 'east-ground',
                src: 'east-piece.glb',
                dotId: 'dotGreen',
                scale: 2.0, // Increased 1.5x from original 1.35
                position: { x: 2.2, y: -0.5, z: -1.5 }, // Right side, surrounding audience
                order: 0,
                color: 'green'
            },
            {
                id: 'south-ground',
                src: 'south-piece.glb',
                dotId: 'dotPink',
                scale: 0.6,  // Keep smaller as requested
                position: { x: 0.0, y: -0.5, z: -0.5 }, // Front, surrounding audience
                order: 1,
                color: 'pink'
            },
            {
                id: 'west-ground',
                src: 'west-piece.glb',
                dotId: 'dotWhite',
                scale: 2.0, // Increased 1.5x from original 1.35
                position: { x: -2.2, y: -0.5, z: -1.5 }, // Left side, surrounding audience
                order: 2,
                color: 'white'
            },
            {
                id: 'north-ground',
                src: 'north-piece.glb',
                dotId: 'dotBlue',
                scale: 0.9, // Keep original size
                position: { x: 0.0, y: -0.5, z: -3.0 }, // Behind audience
                order: 3,
                color: 'blue'
            }
        ];

        let groundCount = 0;
        const awakenedMemories = new Set();
        let draggedDots = new Set();
        let currentAvailableDot = 0;
        let experienceStarted = false;
        let groundCameraDetected = false; // Track which dot should be available
        
        // Get center target position
        function getCenterPosition() {
            const target = document.getElementById('centerTarget');
            const rect = target.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }
        
        // Check if dot is dragged upward to center target
        function isInCenter(dotElement) {
            const dotRect = dotElement.getBoundingClientRect();
            const dotCenter = {
                x: dotRect.left + dotRect.width / 2,
                y: dotRect.top + dotRect.height / 2
            };
            
            const centerPos = getCenterPosition();
            const distance = Math.sqrt(
                Math.pow(dotCenter.x - centerPos.x, 2) + 
                Math.pow(dotCenter.y - centerPos.y, 2)
            );
            
            return distance < 40; // Within 40px of center target
        }

        // Detect when camera is pointing toward ground
        function detectGroundPointing() {
            if (experienceStarted) return;
            
            // Simple detection - user clicks anywhere to start
            document.addEventListener('click', startExperience, { once: true });
            document.addEventListener('touchstart', startExperience, { once: true });
        }
        
        function startExperience() {
            if (experienceStarted) return;
            
            experienceStarted = true;
            console.log('Experience starting - camera pointed to ground');
            
            // Hide start instructions
            document.getElementById('startInstructions').style.display = 'none';
            document.getElementById('instructions').style.display = 'block';
            
            // Show first green dot after delay
            setTimeout(() => {
                showCurrentDot();
            }, 1000);
        }
        
        // Show only current dot sequentially
        function showCurrentDot() {
            if (currentAvailableDot >= groundMemories.length) return;
            
            const currentMemory = groundMemories[currentAvailableDot];
            const currentDot = document.getElementById(currentMemory.dotId);
            
            console.log('Showing dot:', currentMemory.dotId);
            
            // Make current dot visible with animation
            currentDot.classList.add('visible');
            currentDot.style.pointerEvents = 'all';
            
            // Update instruction
            const colorNames = {
                'green': 'green',
                'pink': 'pink',
                'white': 'white', 
                'blue': 'blue'
            };
            document.getElementById('instructions').innerHTML = 
                `Drag ${colorNames[currentMemory.color]} dot to center target`;
        }
        
        // Hide current dot after successful drag
        function hideCurrentDot() {
            if (currentAvailableDot >= groundMemories.length) return;
            
            const currentMemory = groundMemories[currentAvailableDot - 1]; // Previous dot
            const currentDot = document.getElementById(currentMemory.dotId);
            
            // Hide the dot with animation
            currentDot.classList.remove('visible');
            currentDot.style.pointerEvents = 'none';
            
            setTimeout(() => {
                currentDot.style.display = 'none';
            }, 500);
        }

        // Create drag trail line
        function createDragLine(startX, startY, endX, endY, color) {
            const line = document.getElementById('dragLine');
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            
            line.style.left = startX + 'px';
            line.style.top = startY + 'px';
            line.style.height = length + 'px';
            line.style.transform = `rotate(${angle + 90}deg)`;
            line.style.transformOrigin = '0 0';
            line.style.background = `linear-gradient(to top, ${color}, transparent)`;
            line.style.color = color;
            line.style.opacity = '0.6';
        }

        // Hide drag line
        function hideDragLine() {
            const line = document.getElementById('dragLine');
            line.style.opacity = '0';
        }

        // Drag functionality for each dot
        function makeDraggable(dotElement, memoryConfig) {
            let isDragging = false;
            let startPos = { x: 0, y: 0 };
            let startDotPos = { x: 0, y: 0 };
            
            function startDrag(e) {
                // Check if this is the current available dot
                if (memoryConfig.order !== currentAvailableDot || draggedDots.has(dotElement.id)) {
                    console.log('Drag blocked - not current dot or already dragged');
                    return;
                }
                
                console.log('Starting drag for:', dotElement.id);
                isDragging = true;
                dotElement.style.zIndex = '10000 !important';
                dotElement.style.cursor = 'grabbing';
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const rect = dotElement.getBoundingClientRect();
                startPos.x = clientX - rect.left;
                startPos.y = clientY - rect.top;
                
                // Store initial dot position for line drawing
                startDotPos.x = rect.left + rect.width / 2;
                startDotPos.y = rect.top + rect.height / 2;
                
                e.preventDefault();
                e.stopPropagation();
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                console.log('Dragging...');
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const newX = clientX - startPos.x;
                const newY = clientY - startPos.y;
                
                // Force position update
                dotElement.style.position = 'fixed !important';
                dotElement.style.left = newX + 'px !important';
                dotElement.style.top = newY + 'px !important';
                dotElement.style.transform = 'none !important';
                dotElement.style.bottom = 'auto !important';
                
                // Create drag line from start position to current position
                const currentDotX = clientX;
                const currentDotY = clientY;
                
                // Get dot color for line
                const color = memoryConfig.color === 'green' ? 'rgba(0,255,127,1)' :
                             memoryConfig.color === 'pink' ? 'rgba(255,20,147,1)' :
                             memoryConfig.color === 'white' ? 'rgba(255,255,255,1)' :
                             'rgba(173,216,230,1)';
                
                createDragLine(startDotPos.x, startDotPos.y, currentDotX, currentDotY, color);
                
                e.preventDefault();
                e.stopPropagation();
            }
            
            function endDrag(e) {
                if (!isDragging) return;
                
                console.log('Ending drag');
                isDragging = false;
                dotElement.style.cursor = 'grab';
                hideDragLine();
                
                // Check if dot reached center target
                if (isInCenter(dotElement)) {
                    console.log('Dot reached center!');
                    draggedDots.add(dotElement.id);
                    awakenGroundMemory(memoryConfig);
                    hideCurrentDot(); // Hide current dot
                    currentAvailableDot++; // Move to next dot
                    
                    // Show next dot after 3D piece emerges
                    setTimeout(() => {
                        if (currentAvailableDot < groundMemories.length) {
                            showCurrentDot();
                        }
                    }, 3000); // Wait for 3D emergence
                } else {
                    console.log('Dot not in center, resetting position');
                    // Reset position if not successful
                    dotElement.style.position = 'fixed !important';
                    dotElement.style.left = '50% !important';
                    dotElement.style.bottom = '8% !important';
                    dotElement.style.top = 'auto !important';
                    dotElement.style.transform = 'translateX(-50%) !important';
                }
                
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Remove any existing event listeners first
            dotElement.removeEventListener('mousedown', startDrag);
            dotElement.removeEventListener('touchstart', startDrag);
            
            // Add event listeners
            dotElement.addEventListener('mousedown', startDrag, { passive: false });
            dotElement.addEventListener('touchstart', startDrag, { passive: false });
            
            // Add global move and end listeners
            document.addEventListener('mousemove', drag, { passive: false });
            document.addEventListener('mouseup', endDrag, { passive: false });
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag, { passive: false });
        }
        
        function hideDot(dotElement) {
            dotElement.style.opacity = '0';
            dotElement.style.pointerEvents = 'none';
            setTimeout(() => {
                dotElement.style.display = 'none';
            }, 300);
        }

        function awakenGroundMemory(memoryConfig) {
            const container = document.getElementById('ground-container');
            
            // Create memory element starting at center, deep underground
            const memory = document.createElement('a-gltf-model');
            memory.setAttribute('id', memoryConfig.id);
            memory.setAttribute('src', memoryConfig.src);
            memory.setAttribute('position', '0 -1.5 -1.5'); // Start at center underground
            memory.setAttribute('scale', '0.05 0.05 0.05'); // Start very tiny for dramatic scaling
            memory.setAttribute('rotation', '0 0 0');
            memory.setAttribute('visible', false);
            
            // 3x FASTER emergence from center underground
            memory.setAttribute('animation__center-emerge', 
                'property: position; from: 0 -1.5 -1.5; to: 0 0.2 -1.5; ' +
                'dur: 3000; easing: easeOutQuart; startEvents: centerEmerge'
            );
            
            // 3x SLOWER scale growth for dramatic effect
            memory.setAttribute('animation__dramatic-scale', 
                `property: scale; from: 0.05 0.05 0.05; to: ${memoryConfig.scale} ${memoryConfig.scale} ${memoryConfig.scale}; ` +
                'dur: 24000; easing: easeOutElastic; startEvents: dramaticScale'
            );
            
            // Fast swirling while at center
            memory.setAttribute('animation__center-swirl', 
                'property: rotation; from: 0 0 0; to: 0 1440 0; ' +
                'dur: 4000; easing: easeOutQuart; startEvents: centerSwirl'
            );
            
            // Movement to surrounding position after center emergence
            memory.setAttribute('animation__surround-move', 
                'property: position; ' +
                `from: 0 0.2 -1.5; to: ${memoryConfig.position.x} ${memoryConfig.position.y + 0.2} ${memoryConfig.position.z}; ` +
                'dur: 5000; easing: easeInOutQuart; startEvents: surroundMove'
            );
            
            // Continue rotation during movement
            memory.setAttribute('animation__move-swirl', 
                'property: rotation; from: 0 1440 0; to: 0 1800 0; ' +
                'dur: 5000; easing: easeInOutQuart; startEvents: moveSwirl'
            );
            
            // FASTER dancing breathing at final position
            memory.setAttribute('animation__dance-breathe', 
                `property: position; from: ${memoryConfig.position.x} ${memoryConfig.position.y + 0.2} ${memoryConfig.position.z}; ` +
                `to: ${memoryConfig.position.x} ${memoryConfig.position.y + 0.4} ${memoryConfig.position.z}; ` +
                'dir: alternate; dur: 2500; easing: easeInOutSine; loop: true; startEvents: danceBreathe'
            );
            
            // FASTER dancing rotation
            memory.setAttribute('animation__dance-spin', 
                'property: rotation; from: 0 1800 0; to: 0 2160 0; ' +
                'dur: 30000; easing: linear; loop: true; startEvents: danceSpin'
            );
            
            // Additional rhythmic swaying for dance effect
            memory.setAttribute('animation__dance-sway', 
                'property: rotation; from: 0 0 -3; to: 0 0 3; ' +
                'dir: alternate; dur: 3000; easing: easeInOutSine; loop: true; startEvents: danceSway'
            );
            
            // Rhythmic scale breathing for life effect
            memory.setAttribute('animation__scale-breathing', 
                `property: scale; from: ${memoryConfig.scale} ${memoryConfig.scale} ${memoryConfig.scale}; ` +
                `to: ${memoryConfig.scale * 1.05} ${memoryConfig.scale * 1.05} ${memoryConfig.scale * 1.05}; ` +
                'dir: alternate; dur: 3500; easing: easeInOutSine; loop: true; startEvents: scaleBreathing'
            );
            
            container.appendChild(memory);
            
            // Timing sequence: center emergence → move to surround → dancing life
            memory.addEventListener('model-loaded', function() {
                // 1. Start at center underground
                setTimeout(() => {
                    memory.setAttribute('visible', true);
                    memory.emit('centerEmerge');
                    memory.emit('centerSwirl');
                }, 500);
                
                // 2. Start dramatic scaling while emerging
                setTimeout(() => {
                    memory.emit('dramaticScale');
                }, 1000);
                
                // 3. Move to surrounding position
                setTimeout(() => {
                    memory.emit('surroundMove');
                    memory.emit('moveSwirl');
                }, 4000); // After center emergence
                
                // 4. Start dancing life motions at final position
                setTimeout(() => {
                    memory.emit('danceBreathe');
                    memory.emit('danceSpin');
                    memory.emit('danceSway');
                    memory.emit('scaleBreathing');
                }, 9000); // After movement to position
            });
            
            memory.addEventListener('model-error', function() {
                console.log(`Failed to awaken ${memoryConfig.id} from ground`);
            });
            
            awakenedMemories.add(memoryConfig.id);
            groundCount++;
            updateGroundProgress();
        }

        function updateGroundProgress() {
            document.getElementById('count').textContent = groundCount;
            
            if (groundCount >= 4) {
                // Ground awareness complete
                setTimeout(() => {
                    document.getElementById('instructions').style.display = 'none';
                    document.getElementById('centerTarget').style.display = 'none';
                    document.getElementById('groundComplete').style.display = 'block';
                }, 2000);
            } else {
                // Update instruction for current piece
                const currentMemory = groundMemories[currentAvailableDot];
                if (currentMemory) {
                    const instructions = {
                        'green': 'Drag glowing green dot to center target',
                        'pink': 'Drag glowing pink dot to center target', 
                        'white': 'Drag glowing white dot to center target',
                        'blue': 'Drag glowing blue dot to center target'
                    };
                    document.getElementById('instructions').innerHTML = instructions[currentMemory.color];
                }
            }
        }': 'pink', 
                        'dotWhite': 'white',
                        'dotBlue': 'blue'
                    };
                    const nextColor = colorNames[nextPiece.dotId];
                    document.getElementById('instructions').innerHTML = `Drag ${nextColor} dot to center`;
                }
            }
        }

        // Initialize ground detection
        detectGroundPointing();
        
        // Initialize draggable dots (all hidden initially)
        groundMemories.forEach(memory => {
            const dot = document.getElementById(memory.dotId);
            makeDraggable(dot, memory);
        });

        // Zoom for detailed ground observation
        let lastTouchDistance = 0;
        let isZooming = false;

        document.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                isZooming = true;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                e.preventDefault();
            }
        });

        document.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && isZooming) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                const scale = currentDistance / lastTouchDistance;
                observeGround(scale);
                lastTouchDistance = currentDistance;
                e.preventDefault();
            }
        });

        document.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                isZooming = false;
            }
        });

        function observeGround(scaleFactor) {
            awakenedMemories.forEach(memoryId => {
                const memory = document.getElementById(memoryId);
                if (memory && memory.getAttribute('visible')) {
                    const currentScale = memory.getAttribute('scale');
                    const newScale = {
                        x: Math.max(0.3, Math.min(1.2, currentScale.x * scaleFactor)),
                        y: Math.max(0.3, Math.min(1.2, currentScale.y * scaleFactor)),
                        z: Math.max(0.3, Math.min(1.2, currentScale.z * scaleFactor))
                    };
                    memory.setAttribute('scale', newScale);
                }
            });
        }

        // Reset ground awareness
        function resetGroundAwareness() {
            const container = document.getElementById('ground-container');
            container.innerHTML = '';
            
            groundCount = 0;
            currentAvailableDot = 0; // Reset to first dot
            awakenedMemories.clear();
            draggedDots.clear();
            
            document.getElementById('count').textContent = '0';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('instructions').innerHTML = 'Drag green dot to center';
            document.getElementById('centerTarget').style.display = 'block';
            document.getElementById('groundComplete').style.display = 'none';
            
            // Reset all dots
            groundMemories.forEach(memory => {
                const dot = document.getElementById(memory.dotId);
                dot.style.display = 'block';
                dot.style.pointerEvents = 'all';
                dot.style.position = 'absolute';
                dot.style.zIndex = '999';
                
                // Reset to original positions
                dot.style.left = '';
                dot.style.top = '';
                
                // Only first dot available initially
                if (memory.order === 0) {
                    dot.style.opacity = '0.8';
                } else {
                    dot.style.opacity = '0.3';
                    dot.style.pointerEvents = 'none';
                }
            });
        }

        // Gentle shake to reset
        let shakeTimeout;
        window.addEventListener('devicemotion', function(event) {
            if (event.acceleration && 
                (Math.abs(event.acceleration.x) > 12 || 
                 Math.abs(event.acceleration.y) > 12 || 
                 Math.abs(event.acceleration.z) > 12)) {
                
                clearTimeout(shakeTimeout);
                shakeTimeout = setTimeout(resetGroundAwareness, 1000);
            }
        });

        // Prevent context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
    </script>
</body>
</html>
